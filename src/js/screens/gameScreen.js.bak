/**
 * CNP インベーダー - 和風インベーダーゲーム
 * Version: 0.1.2
 * SPDX-License-Identifier: MIT
 */

import { Player } from '../entities/player.js';
import { Enemy } from '../entities/enemy.js';
import { UFO } from '../entities/ufo.js';
import { Boss } from '../entities/boss.js';

export class GameScreen {
  constructor(game) {
    this.game = game;
    this.canvas = game.canvas;
    this.ctx = game.ctx;
    
    // ゲーム要素
    this.player = null;
    this.enemies = [];
    this.playerBullets = [];
    this.enemyBullets = [];
    this.ufo = null;
    this.boss = null;
    
    // ゲーム状態
    this.gameTime = 0; // ゲーム経過時間（秒）
    this.bossSpawnTime = 180; // ボス出現時間（秒）
    this.enemyRows = 5; // 敵の行数
    this.enemyCols = 8; // 敵の列数
    this.enemySpacing = 60; // 敵の間隔
    this.enemySpeed = 50; // 敵の基本速度
    this.enemySpeedIncrease = 5; // 敵が減るごとの速度増加
    this.enemyDropDistance = 20; // 敵が下に降りる距離
    this.enemyDirection = 1; // 敵の移動方向 (1: 右, -1: 左)
    
    // スコア表示
    this.scoreDisplay = null;
    
    // UIコントロール
    this.chargeBar = null;
  }
  
  // 画面に入る時の処理
  async enter() {
    try {
      console.log('ゲーム画面にenterしました');
      
      // デバッグ情報更新
      const debugInfo = document.getElementById('debug-info');
      if (debugInfo) debugInfo.textContent = 'ゲーム画面初期化中...';
      
      // ゲーム状態を初期化
      this.gameOver = false;
      this.collisionEnabled = false; // 初期化中は衝突判定を無効化
      
      // 既存のHTML UIを非表示にする
      const existingUI = document.getElementById('game-ui');
      if (existingUI) {
        console.log('既存のHTML UIを非表示にします');
        existingUI.style.display = 'none';
      } else {
        console.log('既存UIが見つかりません');
      }
      
      // キャンバスを表示
      if (this.canvas) {
        console.log('キャンバスを表示します');
        this.canvas.style.display = 'block';
      }
      
      // ゲームの初期化
      console.log('ゲーム初期化を開始します');
      this.initializeGame();
      
      // プレイヤーが正しく生成されたか確認
      if (!this.player) {
        console.error('プレイヤーが正しく生成されていません');
        // 再度プレイヤーを生成
        const Player = (await import('../entities/player.js')).Player;
        this.player = new Player(
          this.game,
          this.canvas.width / 2,
          this.canvas.height - 100
        );
        console.log('プレイヤーを再生成しました:', this.player);
      }
      
      // チャージバーとスコア表示を作成
      this.createChargeBar();
      this.createScoreDisplay();
      
      // デバッグ情報更新
      if (debugInfo) debugInfo.textContent = 'ゲーム画面表示中';
      
      // 少し遅延させてから衝突判定を有効化
      setTimeout(() => {
        this.collisionEnabled = true;
        console.log('衝突判定を有効化しました');
      }, 1000);
      
      console.log('ゲーム画面の初期化が完了しました');
    } catch (error) {
      console.error('ゲーム画面の初期化エラー:', error);
      
      // デバッグ情報更新
      const debugInfo = document.getElementById('debug-info');
      if (debugInfo) debugInfo.textContent = `エラー: ゲーム画面初期化失敗 - ${error.message}`;
      this.ctx.fillText('初期化エラーが発生しました:', 10, 50);
      this.ctx.fillText(error.message, 10, 80);
    }
  }
  
  // 画面から出る時の処理
  exit() {
    console.log('ゲーム画面からexitします');
    
    try {
      // デバッグ情報更新
      const debugInfo = document.getElementById('debug-info');
      if (debugInfo) debugInfo.textContent = 'ゲーム画面終了中...';
      
      this.removeScoreDisplay();
      this.removeChargeBar();
      
      // デバッグ情報更新
      if (debugInfo) debugInfo.textContent = 'ゲーム画面終了';
      
      console.log('ゲーム画面からの退出が完了しました');
    } catch (error) {
      console.error('ゲーム画面の終了エラー:', error);
      
      // デバッグ情報更新
      const debugInfo = document.getElementById('debug-info');
      if (debugInfo) debugInfo.textContent = `エラー: ゲーム画面終了失敗 - ${error.message}`;
    }
  }
  
  // ゲームの初期化
  initializeGame() {
    console.log('ゲーム初期化開始');
    
    try {
      // プレイヤーの作成
      this.player = new Player(
        this.game,
        this.canvas.width / 2,
        this.canvas.height - 100
      );
      console.log('プレイヤー作成成功:', this.player);
      
      // プレイヤー画像の読み込み確認
      if (this.player.image) {
        this.player.image.onload = () => {
          console.log('プレイヤー画像読み込み完了');
        };
        
        this.player.image.onerror = (error) => {
          console.error('プレイヤー画像読み込みエラー:', error);
        };
      }
      
      // 敵の配置
      this.createEnemies();
      console.log('敵作成成功:', this.enemies.length);
      
      // 各種配列の初期化
      this.playerBullets = [];
      this.enemyBullets = [];
      this.ufo = null;
      this.boss = null;
      
      // ゲーム状態のリセット
      this.gameTime = 0;
      this.gameOver = false;
      this.game.scoreManager.resetScore();
      
      console.log('ゲーム初期化完了');
    } catch (error) {
      console.error('ゲーム初期化エラー:', error);
    }
  }
  
  // 敵の配置
  createEnemies() {
    this.enemies = [];
    
    // 画面端から十分に離して敵を配置する
    const marginX = 80; // 画面端からの余白
    const usableWidth = this.canvas.width - marginX * 2;
    const enemySpacing = usableWidth / (this.enemyCols - 1);
    const startX = marginX;
    const startY = 50; // 初期位置を上方に調整
    
    for (let row = 0; row < this.enemyRows; row++) {
      for (let col = 0; col < this.enemyCols; col++) {
        const x = startX + col * this.enemySpacing;
        const y = startY + row * this.enemySpacing;
        
        // 敵クラスのデフォルト設定を尊重する
        const enemy = new Enemy(this.game, x, y);
        
        // 行によって敵の特性を変える（オプション）
        if (row === 0) {
          enemy.points = 150; // 最前列は高得点
        }
        
        // ゲーム画面の幅を敵クラスに渡す
        enemy.canvasWidth = this.canvas.width;
        
        this.enemies.push(enemy);
      }
    }
  }
  
  // 更新処理
  update(deltaTime) {
    // ゲームオーバーなら何もしない
    if (this.gameOver) return;
    
    // デバッグ情報を追加
    if (Math.floor(this.gameTime) !== Math.floor(this.gameTime + deltaTime)) {
      console.log('ゲーム時間:', Math.floor(this.gameTime + deltaTime), '秒');
    }
    
    // ゲーム時間の更新
    this.gameTime += deltaTime;
    
    // プレイヤーの更新
    if (this.player && this.player.isActive) {
      this.player.update(deltaTime);
    }
    
    // 敵の更新
    this.updateEnemies(deltaTime);
    
    // UFOの更新
    this.updateUFO(deltaTime);
    
    // ボスの更新
    this.updateBoss(deltaTime);
    
    // プレイヤーの弾の更新
    this.updatePlayerBullets(deltaTime);
    
    // 敵の弾の更新
    this.updateEnemyBullets(deltaTime);
    
    // 衝突判定
    this.checkCollisions();
    
    // ゲーム状態の確認
    this.checkGameState();
    
    // スコア表示の更新
    this.updateScoreDisplay();
    
    // チャージバーの更新
    this.updateChargeBar();
  }
  
  // 敵の更新
  updateEnemies(deltaTime) {
    if (this.boss) return; // ボス出現中は敵の更新をスキップ
    
    // 敵の移動速度調整は行わず、敵クラスの設定を尊重
    // 敵クラス内で画面端判定と方向転換を行うようにしたので、ここでは単純に更新するのみ
    
    // 敵が残っている場合のみ更新
    if (this.enemies.length > 0) {
      for (let i = this.enemies.length - 1; i >= 0; i--) {
        const enemy = this.enemies[i];
        
        // 敵の更新
        enemy.update(deltaTime);
      }
    }
    
    // 無効になった敵を削除
    this.enemies = this.enemies.filter(enemy => enemy.isActive);
  }
  
  // UFOの更新
  updateUFO(deltaTime) {
    // 既存のUFOの更新
    if (this.ufo) {
      this.ufo.update(deltaTime);
      
      // 無効になったUFOを削除
      if (!this.ufo.isActive) {
        this.ufo = null;
      }
    }
    
    // 新しいUFOの生成チェック
    if (!this.ufo && !this.boss) {
      const newUFO = UFO.checkSpawn(this.game, deltaTime, this.ufo);
      if (newUFO) {
        this.ufo = newUFO;
      }
    }
  }
  
  // ボスの更新
  updateBoss(deltaTime) {
    // ボスの出現条件チェック
    if (!this.boss && (this.gameTime >= this.bossSpawnTime || this.enemies.length === 0)) {
      this.boss = new Boss(this.game);
    }
    
    // ボスの更新
    if (this.boss) {
      this.boss.update(deltaTime);
      
      // ボスが倒されたらゲームクリア
      if (!this.boss.isActive) {
        // ゲームクリア処理
        setTimeout(() => {
          this.game.switchScreen('gameOver');
        }, 1000);
      }
    }
  }
  
  // プレイヤーの弾の更新
  updatePlayerBullets(deltaTime) {
    for (let i = 0; i < this.playerBullets.length; i++) {
      this.playerBullets[i].update(deltaTime);
    }
    
    // 無効になった弾を削除
    this.playerBullets = this.playerBullets.filter(bullet => bullet.isActive);
  }
  
  // 敵の弾の更新
  updateEnemyBullets(deltaTime) {
    for (let i = 0; i < this.enemyBullets.length; i++) {
      this.enemyBullets[i].update(deltaTime);
    }
    
    // 無効になった弾を削除
  
// 画面端から十分に離して敵を配置する
const marginX = 80; // 画面端からの余白
const usableWidth = this.canvas.width - marginX * 2;
const enemySpacing = usableWidth / (this.enemyCols - 1);
const startX = marginX;
const startY = 50; // 初期位置を上方に調整
      // 弾が無効になっていたら次の弾へ
      if (!bullet.isActive) continue;
      
      // ボスとの衝突
      if (this.boss && bullet.collidesWith(this.boss)) {
        if (this.boss.takeDamage(bullet.damage)) {
          // ボスを倒した
          this.game.scoreManager.addScore(this.boss.points);
          this.game.audioManager.play('explosion', 1.0);
        }
        
        // 貫通弾でなければ弾を無効化
        if (!bullet.penetrating) {
          bullet.isActive = false;
        }
      }
    }
    
    // 敵の弾とプレイヤーの衝突
    if (this.player) {
      for (const bullet of this.enemyBullets) {
        if (bullet.collidesWith(this.player)) {
          // プレイヤーがダメージを受ける
          this.handleGameOver();
          bullet.isActive = false;
        }
      }
      
      // 敵とプレイヤーの衝突判定
      for (const enemy of this.enemies) {
        // 敵が画面下端まで降りてきた場合
        // プレイヤーより下に到達した場合にゲームオーバーとする
        if (enemy.y + enemy.height / 2 > this.canvas.height - 50) {
          console.log('敵が画面下端に到達しました');
          console.log('敵のY座標:', enemy.y);
          console.log('画面高さ:', this.canvas.height);
          this.handleGameOver();
          break;
        }
        
        // プレイヤーと敵の直接衝突
        if (this.checkEntityCollision(this.player, enemy)) {
          console.log('プレイヤーと敵が衝突しました');
          console.log('プレイヤー位置:', this.player.x, this.player.y);
          console.log('敵位置:', enemy.x, enemy.y);
          this.handleGameOver();
          break;
        }
      }
    }
  }
  
  // エンティティ同士の衝突判定
  checkEntityCollision(entity1, entity2) {
    // 矩形の衝突判定
    return (
      entity1.x - entity1.width / 2 < entity2.x + entity2.width / 2 &&
      entity1.x + entity1.width / 2 > entity2.x - entity2.width / 2 &&
      entity1.y - entity1.height / 2 < entity2.y + entity2.height / 2 &&
      entity1.y + entity1.height / 2 > entity2.y - entity2.height / 2
    );
  }
  
  // ゲーム状態の確認
  checkGameState() {
    // デバッグ情報を追加
    console.log('ゲーム状態確認中 - 敵数:', this.enemies.length);
    
    // 敵が全滅した場合はクリア
    if (this.enemies.length === 0 && !this.boss) {
      console.log('敵を全滅させました！');
      // TODO: ステージクリア処理
    }
  }
  
  // ゲームオーバー処理
  handleGameOver() {
    if (this.gameOver) return; // 既にゲームオーバー状態なら何もしない
    
    // デバッグ情報を追加
    console.log('ゲームオーバーが発生しました');
    console.log('ゲーム時間:', this.gameTime);
    console.log('敵の数:', this.enemies.length);
    console.log('スタックトレース:', new Error().stack);
    
    this.gameOver = true;
    this.game.audioManager.play('explosion', 1.0);
    
    // プレイヤーを非表示にする
    if (this.player) {
      this.player.isActive = false;
    }
    
    // 少し待ってからゲームオーバー画面へ
    setTimeout(() => {
      this.game.switchScreen('gameOver');
    }, 1500);
  }
  
  // 描画処理
  render(ctx) {
    try {
      // 背景の描画
      this.drawBackground(ctx);
      
      // プレイヤーの描画
      if (this.player) {
        this.player.render(ctx);
      }
      
      // 敵の描画
      for (const enemy of this.enemies) {
        enemy.render(ctx);
      }
      
      // UFOの描画
      if (this.ufo) {
        this.ufo.render(ctx);
      }
      
      // ボスの描画
      if (this.boss) {
        this.boss.render(ctx);
      }
      
      // プレイヤーの弾の描画
      for (const bullet of this.playerBullets) {
        bullet.render(ctx);
      }
      
      // 敵の弾の描画
      for (const bullet of this.enemyBullets) {
        bullet.render(ctx);
      }
      
      // デバッグ情報の描画
      this.renderDebugInfo(ctx);
      
    } catch (error) {
      console.error('ゲーム画面の描画エラー:', error);
      
      // エラー表示
      ctx.fillStyle = '#000000';
      ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
      ctx.fillStyle = '#FF0000';
      ctx.font = '16px Arial';
      ctx.fillText('描画エラーが発生しました:', 10, 50);
      ctx.fillText(error.message, 10, 80);
      
      // デバッグ情報更新
      const debugInfo = document.getElementById('debug-info');
      if (debugInfo) debugInfo.textContent = `エラー: ゲーム描画失敗 - ${error.message}`;
    }
  }
  
  // デバッグ情報の描画
  renderDebugInfo(ctx) {
    // ゲーム状態のデバッグ情報
    ctx.fillStyle = 'rgba(255, 255, 255, 0.7)';
    ctx.font = '12px Arial';
    
    // 敵の数と弾の数を表示
    ctx.fillText(`敵: ${this.enemies.length}`, 10, 20);
    ctx.fillText(`弾: ${this.playerBullets.length}`, 10, 40);
    ctx.fillText(`敵弾: ${this.enemyBullets.length}`, 10, 60);
    
    // ゲーム時間
    const minutes = Math.floor(this.gameTime / 60);
    const seconds = Math.floor(this.gameTime % 60);
    ctx.fillText(`時間: ${minutes}:${seconds < 10 ? '0' : ''}${seconds}`, 10, 80);
    
    // プレイヤー情報
    if (this.player) {
      ctx.fillText(`プレイヤー位置: X=${Math.round(this.player.x)}, Y=${Math.round(this.player.y)}`, 10, 100);
      ctx.fillText(`チャージ: ${Math.round(this.player.chargeTime / this.player.requiredChargeTime * 100)}%`, 10, 120);
      ctx.fillText(`発射可能: ${this.player.canShoot ? '可' : '不可'}`, 10, 140);
    }
    
    // スコア情報
    const score = this.game.scoreManager.getScore();
    const highScore = this.game.scoreManager.getHighScore();
    ctx.fillText(`スコア: ${score}`, 10, 160);
    ctx.fillText(`ハイスコア: ${highScore}`, 10, 180);
    
    // ゲーム状態
    ctx.fillText(`ゲームオーバー: ${this.gameOver ? 'はい' : 'いいえ'}`, 10, 200);
    
    // デバッグ情報更新
    const debugInfo = document.getElementById('debug-info');
    if (debugInfo) {
      const fps = Math.round(1 / (this.game.deltaTime || 0.016));
      debugInfo.textContent = `ゲーム画面実行中 - FPS: ${fps} - 敵: ${this.enemies.length} - スコア: ${score}`;
    }
  }
  
  // 背景の描画
  drawBackground(ctx) {
    // 真っ黒な背景
    ctx.fillStyle = '#000000';
    ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
    // 星空の描画は削除
  }
  
  // 星空の描画関数は削除しました
  
  // プレイヤーの弾を追加
  addBullet(bullet) {
    this.playerBullets.push(bullet);
  }
  
  // 敵の弾を追加
  addEnemyBullet(bullet) {
    this.enemyBullets.push(bullet);
  }
  
  // スコア表示の作成
  createScoreDisplay() {
    const scoreDisplay = document.createElement('div');
    scoreDisplay.className = 'score-display';
    
    const score = this.game.scoreManager.getScore();
    const highScore = this.game.scoreManager.getHighScore();
    
    scoreDisplay.innerHTML = `ハイスコア: ${highScore}<br>スコア: ${score}`;
    
    document.body.appendChild(scoreDisplay);
    this.scoreDisplay = scoreDisplay;
  }
  
  // スコア表示の更新
  updateScoreDisplay() {
    if (this.scoreDisplay) {
      const score = this.game.scoreManager.getScore();
      const highScore = this.game.scoreManager.getHighScore();
      
      this.scoreDisplay.innerHTML = `ハイスコア: ${highScore}<br>スコア: ${score}`;
    }
  }
  
  // スコア表示の削除
  removeScoreDisplay() {
    if (this.scoreDisplay && this.scoreDisplay.parentNode) {
      this.scoreDisplay.parentNode.removeChild(this.scoreDisplay);
    }
  }
  
  // チャージバーの作成
  createChargeBar() {
    const chargeBarContainer = document.createElement('div');
    chargeBarContainer.className = 'special-charge';
    
    const chargeBar = document.createElement('div');
    chargeBar.className = 'charge-bar';
    
    chargeBarContainer.appendChild(chargeBar);
    document.body.appendChild(chargeBarContainer);
    
    this.chargeBar = {
      container: chargeBarContainer,
      bar: chargeBar
    };
  }
  
  // チャージバーの更新
  updateChargeBar() {
    if (this.chargeBar && this.player) {
      if (this.player.isCharging) {
        this.chargeBar.container.style.display = 'block';
        const chargePercent = Math.min(this.player.chargeTime / this.player.requiredChargeTime, 1) * 100;
        this.chargeBar.bar.style.width = `${chargePercent}%`;
        
        if (this.player.specialReady) {
          this.chargeBar.bar.style.backgroundColor = '#ffcc00';
        } else {
          this.chargeBar.bar.style.backgroundColor = '#ffffff';
        }
      } else {
        this.chargeBar.container.style.display = 'none';
      }
    }
  }
  
  // チャージバーの削除
  removeChargeBar() {
    if (this.chargeBar && this.chargeBar.container.parentNode) {
      this.chargeBar.container.parentNode.removeChild(this.chargeBar.container);
    }
  }
}
